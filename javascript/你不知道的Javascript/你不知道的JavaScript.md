作用域

```
"作用域" 定义为一套规则,这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量查找.
```

词法作用域

```
定义在词法阶段的作用域
词法作用域是由你在写代码时将变量和块作用域写在哪里决定的
```

闭包

```
函数可以记住并访问所在的词法作用域时,就产生了闭包.
即使函数在当前词法作用域之外执行.
```

### 关于this

#### 为什么要使用this

```
this 提供了一种优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁并且易于复用。
使用得模式越复杂，显式传递上下文对象会让代码变得越来越混乱。
```

#### 对 this 的 误解

```cmd 
# 指向自身
# this 指向函数的作用域
需要明确的是， this在任何情况下都不指向函数的词法作用域
每当你想把this和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的
```

什么是 this

```
this的上下文取决于函数调用时的各种条件
this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式
当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含
1.函数在哪里被调用（调用栈）
2.函数的调用方法
3.传入的参数等信息
```

#### 总结 

```
this既不指向函数自身也不指向函数的此法作用域
this实际上时在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。
```



### this 全面解析

#### 调用位置（函数的调用方法）

```
调用位置就是函数在代码中被调用的位置（而不是声明的位置）
问题： 这个 this 到底引用的是什么？

最重要就是 分析调用栈（为了到达当前执行位置所调用的所有函数）
我们关心的调用位置就在当前正在执行的函数的前一个调用中。
```

#### 绑定规则

```markdown
# 调用位置如何决定 this 的绑定对象？
1. 必须找到调用位置
2. 判断需要应用四条规则中的哪一条
  1. 默认绑定
  2. 隐式绑定
  3. 显示绑定
  4. new绑定
3. 多条规则都可用时，优先级如何排列
```

##### 默认绑定

- 独立函数调用
  - 不带任何修饰符的函数引用进行调用
  - 严格模式 this is undefined

##### 隐式绑定

- 调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含

##### 隐式丢失

##### 显示绑定

```js
func.call(obj);
func.apply(obj);
// 硬绑定
func.bind(obj);
// API调用上下文
```

##### new 绑定

```markdown
1. 创建（或者说构造）一个全新的对象
2. 这个新对象会被执行[[原型]]对象
3. 这个新对象会绑定到函数调用的this
4. 如果函数没有返回其他对象，那么new 表达式中的函数调用会自动返回这个新对象。
```

#### 优先级

```
默认绑定（最低）
显示绑定 优先级大于 隐式绑定
new绑定 优先级大于 隐式绑定              
```



##### 判断this

```markdown
1. 函数是否在new中调用（new绑定）? 如果是的话this绑定的时新创建的对象.
var bar = new foo()
2. 函数是否通过 call、apply(显式绑定)或者硬绑定(bind)调用? 如果是的话，this绑定的是指定的对象.
var bar = foo.call(obj);
3. 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话,this绑定的是那个上下文对象
var bar = obj1.foo()
4. 如果都不是的话，使用默认绑定.如果在严格模式下，就绑定到undefined，否则绑定到全局对象。
var bar = foo();
```

#### 绑定例外

```js
// 被忽略的this
1.把null或者undefined作为this的绑定对象传入call，apply，bind这些值在调用时会被会略，实际应用的是默认绑定规则
// 间接引用
(p.foo = o.foo)(); // this=>window
// 软绑定

```

##### this 词法

```
 
```

